#version 450

struct planet_struct {
    vec3 pos;
    vec3 velocity;
    float mass;
    float rad;
};

layout(set = 0, binding = 0) buffer Data {
    planet_struct buf[];
} planet_buffer;

layout(push_constant) uniform PushConstantData {
    float time;
    float delta;
    float circular;
} pc;

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

#define G 0.3
#define ACC_BOUNDRY 100.0

struct acc_out {
    vec3 acceleration;
    bool shouldbounce;
    vec3 bouncenormal;
};

acc_out get_acceleration(planet_struct subject, planet_struct object) {
    // Vector from subject to object
    vec3 movement_dir = subject.pos - object.pos;

    // Get the distance between bodies
    float dst = length(movement_dir);

    // Normalize the direction
    movement_dir = normalize(movement_dir);

    // Output structure
    acc_out result;

    // Check for bouncing
    if (dst <= subject.rad + object.rad) {
        result.shouldbounce = true;
        result.bouncenormal = -movement_dir;
    }

    else {
        result.shouldbounce = false;
        result.bouncenormal = vec3(0.0);
    }

    // Calculate the force of gravity and acceleration.
    result.acceleration = clamp(movement_dir * G * object.mass / (dst * dst), vec3(-ACC_BOUNDRY), vec3(ACC_BOUNDRY));

    return result;
}

void main() {
    uint idx = gl_GlobalInvocationID.x;

    // Get current body
    planet_struct subject = planet_buffer.buf[idx];

    // Total acceleration
    vec3 acceleration = vec3(0.0);

    vec3 bounce_velocity = vec3(0.0);
    uint nr_of_bounces = 0;

    // Objects before the subject
    for (uint i = 0; i < idx; ++i) {
        // Get the foregin body
        planet_struct object = planet_buffer.buf[i];

        acc_out info = get_acceleration(subject, object);

        acceleration += info.acceleration;

        // Bounce
        if (info.shouldbounce) {
            bounce_velocity += reflect(planet_buffer.buf[idx].velocity, info.bouncenormal);
            nr_of_bounces += 1;
        }
    }

    // Objects after the subject
    for (uint i = idx + 1; i < gl_NumWorkGroups.x; ++i) {
        // Get the foregin body
        planet_struct object = planet_buffer.buf[i];

        acc_out info = get_acceleration(subject, object);

        acceleration += info.acceleration;
        
        // Bounce
        if (info.shouldbounce) {
            bounce_velocity += reflect(planet_buffer.buf[idx].velocity, info.bouncenormal);
            nr_of_bounces += 1;
        }
    }

    // Bouncing
    if (nr_of_bounces > 0)
        planet_buffer.buf[idx].velocity = bounce_velocity / float(nr_of_bounces);

    // Update the velocity of the body and move the body
    planet_buffer.buf[idx].velocity -= acceleration * pc.delta;
    planet_buffer.buf[idx].pos += planet_buffer.buf[idx].velocity * pc.delta;
}